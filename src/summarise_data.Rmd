---
title: "Summary of psychological ownership survey answers"
author: "Abigail Edwards and Mikko Arvas"
date: "`r Sys.time()`"
output:
  html_document:
    toc: yes
    theme: united
  pdf_document:
    toc: yes
---





```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
library(tidyverse)
library(gtsummary)
library(likert)
library(readxl)
library(here)
library(corrplot)
library(ggstats)
library(lavaan)
library(lavaanPlot)
library(blavaan)
library(manymome)

# https://github.com/cjvanlissa/worcs
# https://cjvanlissa.github.io/worcs/articles/setup.html
# worcs::check_worcs_installation() 

#install.packages("tinytex", dependencies = TRUE)
#library("tinytex")
#install_tinytex()


# https://cjvanlissa.github.io/worcs/reference/add_preregistration.html which template ? 
# https://github.com/crsh/prereg
```


# Data

## Import

```{r}
# file <- here("data/Tulokset - xxxxx.xlsx")
# data <- read_xlsx(file,n_max = XX)
# summary(data)
```

Items
<table>
<tr>
<td></td>
<td> Psychological ownership</td>
</tr>
<tr>
<td>po01</td>
<td>
1. I feel a very high degree of personal ownership of donating blood.
</td>
</tr>
<tr>
<td>po02</td>
<td>
2. I feel like donating blood belongs to me.
</td> </tr>
<tr>
<td>po03</td> <td>
3. I feel like I own donating blood.
</td> </tr>
<tr> <td></td>
<td>
Self-identity
</td> </tr>
<tr>
<td>si01</td>
<td>
1. Donating blood is important to me.
</td> <tr>
<td>si02</td> <td>
2. I am like the kind of person who donates blood.
</td> </tr>
<tr> <td>si03</td> 
<td>
3. Donating blood is an important part of who I am.
</td> </tr>
<tr> <td></td>
<td>
Intention
</td></tr>
<tr><td>it01</td>
<td>
1. I would like to donate blood in the future.
</td>   </tr>
<tr><td>it02</td>
<td>
2. I intend to donate blood in the future.
</td> </tr>
<tr><td>it03</td>
<td>
3. I intend to make more than just a one-off blood donation.
</td></tr>
<tr><td></td>
<td>
Intention to donate for emergency
</td></tr>
<tr><td>ie01</td>
<td>
1. I would be willing to donate blood if I received an urgent callout from the Finnish Red Cross Blood Service.
</td></tr>
<tr><td></td> 
<td>
Antecedents of psychological ownership
</td></tr>
<tr><td></td> 
<td>
Control
</td></tr>
<tr><td>ac01</td>
<td>
1. I have influence over the things that affect me while donating blood.
</td></tr>
<tr><td>ac02</td>
<td>
2. I control the location and scheduling for donating blood.
</td></tr>
<tr><td>ac03</td>
<td>
3. I influence decisions related to my blood donation.
</td></tr>
<tr><td>ac04</td>
<td>
4. In general, I have control over donating blood.
</td></tr>
<tr><td></td>
<td>
Intimate knowledge
</td></tr>
<tr><td>ai01</td>
<td>
1. I am intimately familiar with what is going on with regard to donating blood.
</td></tr>
<tr><td>ai02</td>
<td>
2. I have a depth of knowledge as it relates to donating blood.
</td></tr>
<tr><td>ai03</td>
<td>
3. I have a comprehensive understanding of donating blood.
</td></tr>
<tr><td>ai04</td>
<td>
4. I have a broad understanding of donating blood.
</td></tr>
<tr><td></td>
<td>
Blood donation history
</td></tr>
<tr><td>bd01</td>
<td>
1. Do you believe that you are currently eligible to donate blood [yes, no, unsure]
</td></tr>
<tr><td>bd02</td>
<td>
2. How many times in total have you donated blood at the Finnish Red Cross Blood Service Finland? [select number]
</td></tr>
<tr><td>bd03</td>
<td>
3. How many times in the last two years have you donated at the Finnish Red Cross Blood Service? [select number]
</td></tr>
<tr><td>bd04</td>
<td>
4. When did you last attend a Finnish Red Cross blood donation centre with the intention of donating blood? [select date]
</td></tr>
<tr><td></td>
<td>
Demographics
</td></tr>
<tr><td>de01</td>
<td>1. What is your gender? [man, woman, non-binary, prefer to not disclose, prefer to self-describe (open response)]
</td></tr>
<tr><td>de02</td>
<td>
2. How old are you today? [select number]
</td></tr>
</table>




```{r}
#knitr::knit_exit()
```


```{r}
#Make question abbreviations
qabbr <- c(
    str_c("po0",1:3),
    str_c("si0",1:3),
    str_c("it0",1:3),
    str_c("ie0",1),
    str_c("ac0",1:4),
    str_c("ai0",1:4),
    str_c("bd0",1:4),
    str_c("de0",1:2)
  )

```


## Simulate

All items are scored 1 (strongly disagree) to 7 (strongly agree).

```{r}
#First very rough version

if (TRUE) { # if you have data you set this to false
  n <- 100
  #source("../../responsesR/R/responses.R")
  #create correlation matrix
  #po 3, si 3,  it 3, ie 1, ac 4,ai 4,bd 4, de 2
  #use tidyverse str function to create names str_glue
  R <- matrix(
  #     po          si        it        ie         ac        ai              
  c( 1 ,0.5,0.5,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.5, 1 ,0.5,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.5,0.5, 1 ,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2, 1 ,0.5,0.5,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.5, 1 ,0.5,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.5,0.5, 1 ,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2, 1 ,0.5,0.5,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2,0.5, 1 ,0.5,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2,0.5,0.5, 1 ,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2, 1 ,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2, 1 ,0.5,0.5,0.5,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.5, 1 ,0.5,0.5,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.5,0.5, 1 ,0.5,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.5,0.5,0.5, 1 ,0.2,0.2,0.2,0.2,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2, 1 ,0.5,0.5,0.5,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.5, 1 ,0.5,0.5,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.5,0.5, 1 ,0.5,
    0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.5,0.5,0.5, 1 
    # bd and de are different
    )
  , nrow=18)
    # if you have problems name the columns and rows here
  rownames(R) <- qabbr[1:18]
  colnames(R) <- qabbr[1:18]
  corrplot(R)
  # Only correlations between latents 
}
```



```{r}
#Tried to build to the correlation between latent factors, but...
if (FALSE) { # if you have data you set this to false
  n <- 100
  #create correlation matrix
  #po 3, si 3,  it 3, ie 1, ac 4,ai 4,bd 4, de 2
  R <- matrix(
  #     po           si           it           ie           ac          ai              
  c( 1 ,0.5,0.5,    0.3,0.3,0.3, -0.1,-0.1,-0.1, 0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2,
    0.5, 1 ,0.5,    0.3,0.3,0.3, -0.1,-0.1,-0.1, 0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2, #po
    0.5,0.5, 1 ,    0.3,0.3,0.3, -0.1,-0.1,-0.1, 0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2,

    0.3,0.3,0.3,    1 , 0.5,0.5, 0.7,0.7,0.7,    0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2,
    0.3,0.3,0.3,    0.5, 1 ,0.5, 0.7,0.7,0.7,    0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2, # si
    0.3,0.3,0.3,    0.5,0.5, 1 , 0.7,0.7,0.7,    0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2,
    
    -0.1,-0.1,-0.1, 0.7,0.7,0.7, 1  ,0.5,0.5,    0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2,
    -0.1,-0.1,-0.1, 0.7,0.7,0.7, 0.5, 1 ,0.5,    0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2, #it
    -0.1,-0.1,-0.1, 0.7,0.7,0.7, 0.5,0.5, 1 ,    0.2,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2,
    
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,    1  ,0.2,0.2, 0.2,0.2,0.2, 0.2,0.2,0.2,
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,    0.2, 1 ,0.5, 0.5,0.5,0.2, 0.2,0.2,0.2, # ie
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,    0.2,0.5, 1 , 0.5,0.5,0.2, 0.2,0.2,0.2,
    
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,    0.2,0.5,0.5, 1 , 0.5,0.2, 0.2,0.2,0.2,
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,    0.2,0.5,0.5, 0.5, 1 ,0.2, 0.2,0.2,0.2, # ac
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2, 1 , 0.5,0.5,0.5,
    
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,   0.2,0.2,0.2, 0.2,0.2,0.5,  1 ,0.5,0.5,
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,   0.2,0.2,0.2, 0.2,0.2,0.5, 0.5, 1 ,0.5, # ai
    0.2,0.2,0.2,    0.2,0.2,0.2, 0.2,0.2,0.2,   0.2,0.2,0.2, 0.2,0.2,0.5, 0.5,0.5, 1 
    # bd and de are different. Create them later.
    )
  , nrow=18)
  
  R[R == 0.2] <-0
  rownames(R) <- qabbr[1:18]
  colnames(R) <- qabbr[1:18]
  #Add a bit of noise 
  # R <- R +  matrix(rnorm(n=length(R),mean=0,sd=0.1), nrow=18)
  #Make symmetric
  R[upper.tri(R)] <- t(R)[upper.tri(R)]
  #isSymmetric(R)
  
  #R <- R *0.5
  R <- as.matrix(Matrix::nearPD(R)$mat)
  diag(R) <- 1
  #  Rplot <- round(R,digits = 1)
  #  Rplot[Rplot <= -1] <- -1
  #  Rplot[Rplot >= 1] <- 1
  #   # if you have problems name the columns and rows here
  
  #corrplot(Rplot)
  corrplot(R)
  # When calling responsesR:get_responses always get an error
  # Could not figure out how to simulate depencies between latent variables with usein responsesR
  # But it is good enough for developping the script.
  # Error in msn.cp2dp(cp, silent) : non-admissible CP
 
}
```







```{r}
#simulate data with responsesR::get_responses
if (TRUE) {
library(responsesR)
  
  data_likert_7<- get_responses(n = n,
                K = 7,
                mu = rep(1,nrow(R)),
                gamma1 = -0.1,
                sd = 1,
                R=R
  )
  
  de02 <- round(rnorm(n=n,mean=40,sd =10)) # age
  #de01<- genLikert(size = n,items = 1, levels=4, location=c(-1)) #gender
  de01 <- get_responses(n = n,
                K = 4,
                mu = -1,
                gamma1 = -0.1,
                sd = 0.5
  )
  de01 <-     
      case_when(
      de01 == 1 ~ "women",
      de01 == 2 ~ "man",
      de01 == 3 ~ "Non-binary/other",
      de01 == 4 ~ "Don't wish to respond")
  #bd01 <-  genLikert(size = n,items = 1, levels=3, location=c(-1))
  bd01 <- get_responses(n = n,
                        K = 3,
                        mu = -1,
                        gamma1 = 0.5,
                        sd = 0.7
  )
  bd01 <- case_when(
    bd01 == 1 ~ "yes",
    bd01 == 2 ~ "no",
    bd01 == 3 ~ "unsure",
  )
  data <- bind_cols(
    data_likert_7,
    bd01,
    bd02 = NA,
    bd03 = NA,
    bd04 = NA,
    de01,
    de02
  )
  #colnames(data) <- qabbr[1:ncol(data)]
  colnames(data) <- qabbr
  data <- data %>% 
    mutate(
      # to have some relationship between latent variables make donation counts and po correlate
       bd02 = 
      #take this from po 
         round(as.numeric(po01)  +  
                 as.numeric(po02)   + 
                 as.numeric(data$po03) +
      # and sex
                 0.5*as.numeric(as.factor(de01))   + 
      #with some noise
                 rnorm(nrow(data),0,4) ),
      #make sure it never goes below 1
      bd02 = ifelse(bd02 < 2 ,1,bd02),
      # and count donation in last two years from it with some noise
      bd03 = round(ceiling(bd02 / 5) + rnorm(nrow(data),0,1)),
      bd04 = sample(seq(as.Date('2022/01/01'), as.Date('2024/01/01'), by="day"), n)
    )
  
  
  
  summary(data)
}
```



## Process

```{r}

f1 <- function (x){
  #as numbers but labelled with words
    x <- factor(
    x,
    #levels = c("Strongly disagree","Disagree","Neutral","Agree","Strongly agree"),
    levels = c(1:7),
    ordered = TRUE
  )
  x
}

data <- data %>% 
  mutate_at(
    vars(
      qabbr[1:18]),
    ~ f1(.) 
    ) %>% 
  mutate(bd04 = as.Date(bd04),
         bd01 = factor(bd01, levels = c("no","unsure","yes"),ordered = TRUE),
         de01 = factor(de01)
         )  

summary(data)

```


# Plot

the responsesR likert plots look really good...


## Demographics Table 1

```{r}

table1 <-
  tbl_summary(
    data %>% 
      # mutate(
      #   bd01 = as.character(bd01) # this did fix this need to think of something
      # ) %>% 
      rename(
      Gender =  de01,
      Age = de02,
      DonationEligibility = bd01,
      DonationCount = bd02,
      DonationCountLast2years = bd03,
    ),
    include = c(
      Age,
      DonationEligibility,
      DonationCount,
      DonationCountLast2years
      ),
    by =  Gender
    
  ) %>%
  add_n()  # add column with total number of non-missing observations
table1
```



## Age by Gender

```{r}

p <- ggplot(data)
p <- p +  geom_histogram(aes(x=de02),binwidth = 5)
p <- p + facet_wrap(. ~ de01)
p <- p + xlab("Age in years")
p

```



## Psychological ownership

```{r , warning=FALSE}
nlevels = 7

items = data %>% 
    select(which(str_detect(colnames(data) ,"^po"))) 

#rename the questions in here from metadata

qpo <- likert(
  items = as.data.frame(items),
  nlevels = nlevels
  
)
plot(qpo, 
     type = "heat",
     legend.position = "bottom",
     text.size=3,
     include.histogram = FALSE)
```

```{r}

gglikert(
  data %>% 
    select(which(str_detect(colnames(data) ,"^po"))) 
)

```




## Self-identity


```{r , warning=FALSE}

items = data %>% 
    select(which(str_detect(colnames(data) ,"^si"))) 

#rename the questions in here from metadata
qsi <- likert(
  items = as.data.frame(items),
  nlevels = nlevels
  
)
plot(qsi, 
     type = "heat",
     legend.position = "bottom",
     text.size=3,
     include.histogram = FALSE)
```


## Intention

```{r , warning=FALSE}

items = data %>% 
    select(which(str_detect(colnames(data) ,"^it"))) 

#rename the questions in here from metadata
qit <- likert(
  items = as.data.frame(items),
  nlevels = nlevels
  
)
plot(qit, 
     type = "heat",
     legend.position = "bottom",
     text.size=3,
     include.histogram = FALSE)
```


## Intention to donate for emergency

```{r , warning=FALSE}

items = data %>% 
    select(which(str_detect(colnames(data) ,"^ie"))) 

#rename the questions in here from metadata
qie <- likert(
  items = as.data.frame(items),
  nlevels = nlevels
  
)
plot(qie, 
     type = "heat",
     legend.position = "bottom",
     text.size=3,
     include.histogram = FALSE)
```


## Antecedents of psychological ownership - Control

```{r , warning=FALSE}

items = data %>% 
    select(which(str_detect(colnames(data) ,"^ac"))) 

#rename the questions in here from metadata
qac <- likert(
  items = as.data.frame(items),
  nlevels = nlevels
  
)
plot(qac, 
     type = "heat",
     legend.position = "bottom",
     text.size=3,
     include.histogram = FALSE)
```


## Antecedents of psychological ownership - Intimate knowledge


```{r , warning=FALSE}

items = data %>% 
    select(which(str_detect(colnames(data) ,"^ai"))) 

#rename the questions in here from metadata
qai <- likert(
  items = as.data.frame(items),
  nlevels = nlevels
  
)
plot(qai, 
     type = "heat",
     legend.position = "bottom",
     text.size=3,
     include.histogram = FALSE)
```


# Model


```{r}

library(lavaan)
#library(blavaan) # tidySEM requires blavaan
#library(tidySEM) # https://github.com/yrosseel/lavaan/issues/359 lavaan does not work if tidySEM is loaded.

```


## Confirmatory factor analysis

```{r}
isordered <- data %>%  summarise(across(everything(), ~ is.ordered(.x))) %>%  as.logical() %>% which()
isfactor <- data %>%  summarise(across(everything(), ~ is.factor(.x))) %>%  as.logical() %>% which()

#lavaan does not understand empty factor levels
data.fit <- data %>%
  #lavaan cannot deal with unordered factor with more then 2 levels
  filter(de01 == 'man' | de01 == "women") %>% 
  mutate(
    across(isfactor, ~ fct_drop(.x)
    ) %>% 
      mutate(
        bd04 = as.numeric(bd04) # lavaan cannot handle dates
      )
  )

```




```{r}
po01.model <- ' po =~ po01 + po02 + po03
                si =~ si01 + si02 + si03
                it =~ it01 + it02 + it03
                ac =~ ac01 + ac02 + ac03 + ac04
                ai =~ ai01 + ai02 + ai03 + ai04 
                #bd =~ bd01 + bd02 + bd03 + bd04
                bd =~ bd02 + bd01 + bd03 + bd04 #bd02 is sure correlate positively

'
                
fit.po01.cfa <- cfa(po01.model,  
                    estimator = "DWLS",
                    data = data.fit)
fit.po01.cfa
# Minimum function test statistic is chi^2
```


```{r}
lavaan::summary(fit.po01.cfa,standardized = TRUE) # tidySEM is loaded this fails!
#lavaan::summary(fit.po01.cfa) # tidySEM is loaded this fails!

#The estimate is the non-standardised as can be seen from the fact that
#the first item is always 1. Then the standardised are in the "Std" columns.
#"Std.all" is "factor loading" and crude rule if thumb is that abs(Std.all) should be above 0.3
#With simulated data bd04 is just random so it should be smaller than others.
```

```{r}
#lavaan::parameterestimates(fit.po02)
# Check items which correlate poorly with their latent factor
cfastd <- lavaan::standardizedsolution(fit.po02)
cfastd %>% 
  filter(abs(est.std) < 0.3) %>% 
  select(-label,-z,-se) %>% 
  arrange(abs(est.std)) %>% 
  # Just the loadings
  filter(op == '=~')

```


```{r}
lavaan::fitmeasures(fit.po02,c("npar","chisq","df","cfi","rmsea","srmr"))
```


```{r}
lavaanPlot(
  fit.po01.cfa,
   edge_options = list(color = "grey"),
  coefs = TRUE,
  graph_options = list(rankdir = "LR")
           )
```


```{r}
#Make a model with out prespesified correlation structure
fit.po01.cfa.o <- cfa(po01.model,data.fit,orthogonal=TRUE)
round(
  sapply(list(cfa=fit.po01.cfa,cfa.o=fit.po01.cfa.o),
         function(x) fitmeasures(x,c("npar","chisq","df","cfi","rmsea","srmr"))
         )
,3)

#cfa should be better than cfa.o in all measures. cfi should be bigger, chi and srmr smaller in model cfa
```

```{r}
#anova(fit.po01.cfa,fit.po01.cfa.o)
#Error: lavaan->lavTestLRT(): 
#some models (but not all) have scaled test statistics
```



## SEM

### Basic SEM

```{r}
#https://stats.stackexchange.com/questions/340857/serial-mediation-in-r-how-to-setup-the-model

# N.B. you need to check that first item is positively correlated with your latent factor
# Otherwise you get opposite direction 

po02.model <- ' 
#measurement model
psycown =~ po01 + po02 + po03
selfid =~ si01 + si02 + si03
intention =~ it01 + it02 + it03
#psycown_cont =~ ac01 + ac02 + ac03 + ac04
#psycown_know =~ ai01 + ai02 + ai03 + ai04 
blooddonor =~ bd02 + bd01 + bd03 +bd04 # do we want to include the DATE OF LAST DONATION?
#mediation
psycown ~ a1 *  blooddonor
selfid ~ a2 * blooddonor + d21 * psycown
#regression
intention ~  de01 + de02 + ie01 +  cp * blooddonor + b1 * psycown + b2 * selfid
ind_eff := a1* d21 * b2
'

cat(po02.model)

```


```{r}
#fit
                
fit.po02 <- sem(po02.model,  
                    estimator = "DWLS",
                    data = data.fit
                #SHOULD SOME OTHER PARAMETERS BE SET?
                  )

# Warning: lavaan->lav_data_full():  
#    exogenous variable(s) declared as ordered in data: "ie01"
# Warning: lavaan->lav_data_full():  
#    some observed variances are (at least) a factor 1000 times larger than others; use varTable(fit) to investigate
#SHOULD SOMETHING BE DONE ABOUT THIS?

lavaan::summary(fit.po02,standardized = TRUE)

```

```{r}
varTable(fit.po02)
```

IS ie01 a problem? should it be numeric?
IS bd04 a problem? should we reduce its variation by scaling it down?



```{r}
#inspect(fit,what="")
lavaan::inspect(fit.po02,"r2")
```



```{r}
lavaan::standardizedsolution(fit.po02) %>% select(-label)
```

```{r}
lavaan::standardizedsolution(fit.po02) %>% select(-label,se,z) %>%  filter(op == '~')
```



```{r}

labelsforplotting <- c(
  "psycown" = "Psychological ownership",
  "selfid"  = "Self-identity",
  "intention" = "Intention",
  "blooddonor " = "Blood donation history"
)

lavaanPlot(
  model=fit.po02,  
  coefs = TRUE,
  node_options = list(shape = "box", fontname = "Helvetica"), 
  edge_options = list(color = "grey"), 
  labels = labelsforplotting,

  #In simulated data there should be correlations inside
  # bloodonor, psycown, selfid
  # and between
  # bloodonor, psycown
  # and nothing else
  sig = 0.001
  # if sig is < 0.001 one gets significant correlations
  # also from simulated data elsewhere suggesting that 0.05 is not enough
  # BAYESIN AND/OR BOOTSTRAP SHOULD BE MADE TO WORK
  )
```

```{r}
# Same with standardised coefficients
lavaanPlot(
  model = fit.po02, 
   labels = labelsforplotting,
  node_options = list(shape = "box", fontname = "Helvetica"), 
  edge_options = list(color = "grey"), 
  coefs = TRUE, 
  stand = TRUE,
  sig=0.001
  )
```


```{r}

#lavaan::lavInspect()
#lavOptions
#?"lavaan-class"
```



```{r}
#fit.po02.boot <- bootstrapLavaan(fit.po02)
#Error: lavaan->bootstrapLavaan(): 
#this function is not (yet) available if conditional.x = TRUE
```






### SEM with bootstrapping

```{r}

# To make bootstrapping run there cannot be any unordered factors
data.fit2 <- data.fit %>% 
  mutate(
    de01 = as.ordered(de01)
  ) %>% # and neither any factors at all
mutate(
  across(everything(),as.numeric)
)  
#fit
                
fit.po03 <- sem(po02.model,  
                    estimator = "ML", # as we have factors we do not need to use DWLS. IS something else better?
                    data = data.fit2,
                #fixed.x=FALSE #  fixed.x = FALSE is not supported when conditional.x = TRUE
                conditional.x = FALSE # THIS DOES NOT WORK, HOW TO FIX?
                )

lavaan::summary(fit.po03,standardized = TRUE)

```



```{r}
lavaanPlot(
  model = fit.po03, 
   labels = labelsforplotting,
  node_options = list(shape = "box", fontname = "Helvetica"), 
  edge_options = list(color = "grey"), 
  coefs = TRUE, 
  stand = TRUE,
  sig=0.001
  )


```



```{r}
if (FALSE) {
# As the fit.po03 with conditional.x TRUE does not the bootstrapping does not work either
# Warning: lavaan->bootstrapLavaan():  
#   1000 bootstrap runs failed or did not converge.
# fit.po03.boot <- bootstrapLavaan(
#   fit.po03,
#   FUN = "coef",
#   parallel = "multicore",
#   iseed = 74
#   )
#Error: lavaan->bootstrapLavaan(): 
#this function is not (yet) available if conditional.x = TRUE

  # https://groups.google.com/g/lavaan/c/A6KCjXAZl-Q
#>nBoots <- 1000
#>SEM.model <- sem(Model, data = Dataset, se = "boot", test = "Bollen.Stine", bootstrap = nBoots)
#>parameterEstimates(SEM.model, boot.ci.type = "norm", standardized = TRUE)

# HS.model <- ' visual =~ x1 + x2 + x3
# textual =~ x4 + x5 + x6
# speed =~ x7 + x8 + x9 '
# 
# fit <- cfa(HS.model, data=HolzingerSwineford1939)
# 
# out <- bootstrapLavaan(fit, R = 100, FUN = function(x) {
# standardizedSolution(x)$est }, verbose = TRUE)
# 
# This will return a 100x24 matrix (in practice, you may want to use a
# much larger number for R). The rows are the bootstraps, the columns are
# the model parameters (here including fixed parameters).
# 
# To get a 95% CI, you can compute percentiles on the columns of out:
# 
# # just one column:
# quantile(out[,1], probs=c(0.025, 0.975))
# 
# # all columns
# lapply(as.data.frame(out), quantile, probs=c(0.025, 0.975))
# 
# 
# To bootstrap one of more fit measures, you can use something like:
# 
# out <- bootstrapLavaan(fit, R = 100, FUN = function(x) { fitMeasures(x,
# c("cfi", "rmsea")) }, verbose = TRUE) 



summary(fit.po03.boot)
}

```

THIS WORKS BUT HOW COUNT ci FROM THEM THEM?
https://stackoverflow.com/questions/48612153/how-to-calculate-confidence-intervals-for-a-vector something like this if libraries won't work.

Compare bootstrapped to original

```{r}
# 
# x <- fit.po03.boot[,1]
# bootout <-list(t0 =  x,t = length(x))
# 
# boot::boot.ci(bootout)

```

```{r}
# https://cran.r-project.org/web/packages/semhelpinghands/vignettes/standardizedSolution_boot_ci.html
#another option

#https://blogonresearch.github.io/posts/bootstrap_confidence_intervals_for_standardized_solution_in_lavaan/
```



```{r}
# Would manymome work better?
#https://sfcheung.github.io/manymome/articles/manymome.html
#https://sfcheung.github.io/manymome/index.html 
# boot_out_lavaan <- do_boot(fit = fit_lavaan,
#                            R = 500,
#                            ncores = 1,
#                            seed = 58491)


fit.po03 <- sem(po02.model,  
                    estimator = "ML", # as we don't have factors anymore we do not need to use DWLS. IS something else better?
                    data = data.fit2,
                se = "boot"
                )
```



```{r}
fit.po03
```


```{r}
fit.po03.best <- parameterEstimates(fit.po03)[parameterEstimates(fit.po03)$op == "~", ]
fit.po03.best %>% select(-se,-z)
```


```{r}
out_med <- indirect_effect(x = "blooddonor",
                           y = "intention",
                           m = c("psycown", "selfid"),
                           fit = fit.po03,
                           boot_ci = TRUE,
                           R = 500,
                           seed = 43143,
                           ncores = 4)


```

```{r}
out_med
```



```{r}
out_x_m2_y
```


### BAYESIN SEM




```{r}
#fit
                
fit.po04 <- blavaan(po02.model,  
                    #estimator = "DWLS",
                    data = data.fit2,
                #SHOULD SOME OTHER PARAMETERS BE SET?
                n.chains = 4,
                sample = 100,
                mcmcfile =  here("results/fit.po04.rdata")
                  )


summary(fit.po04,standardized = TRUE)

```







## Improvements for SEM 

### How do the residuals look ?

```{r}
#plot correlations from SEm
lavaan::inspect(fit.po02,"est")$gamma

```

```{r}
#lavaan::inspect(fit.po02,"sampstat")$res.cov
```

```{r}
#residual correlation matrix i.e. how much correlation between 2 items is not captured by the model
corrplot(resid(fit.po02,type="cor")$res.cov)
```

### Whats is suggested by modification indices ?

```{r}
mod_ind <- modificationindices(fit.po02)
mod_ind <- mod_ind %>% arrange(desc(mi)) %>% filter(mi>10)
mod_ind
```

### Implement them

```{r}

po02.model.mi <- paste(
  po02.model,
  str_c(mod_ind$lhs," ", mod_ind$op," ",mod_ind$rhs,collapse = "\n")
)
cat(po02.model.mi)
```


```{r}
#fit
                
fit.po02.mi <- sem(po02.model.mi,  
                    estimator = "DWLS",
                    data = data.fit
                #SHOULD SOME OTHER PARAMETERS BE SET?
)

lavaan::summary(fit.po02,standardized = TRUE)


```

```{r}
# Same with standardised coefficients
lavaanPlot(
  model = fit.po02.mi, 
   labels = labelsforplotting,
  node_options = list(shape = "box", fontname = "Helvetica"), 
  edge_options = list(color = "grey"), 
  coefs = TRUE, 
  stand = TRUE,
  sig=0.001
  )
```


```{r}

round(
  sapply(list(sem.ori=fit.po02,sem.mi=fit.po02.mi),
         function(x) fitmeasures(x,c("npar","chisq","df","cfi","rmsea","srmr"))
         )
,3)


```

